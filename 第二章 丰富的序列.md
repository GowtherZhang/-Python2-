# 丰富的序列

[[_TOC_]]

# 2.3 列表推导式和生成器表达式

## 列表推导式对可读性的影响

ord 函数用来返回单个字符的 ascii 值或者 unicode 值

chr 函数用来返回一个整数对应的 ascii 字符

我们可以使用 chr 函数来造一个字符串：

```python
symbols = chr(36)+chr(162)+chr(163)+chr(165)+chr(8364)+chr(164)
symbols

'$¢£¥€¤'
```

反过来，利用 ord 函数结合列表推导式，我们可以构建一个 unicode 码点列表

```python
codes = [ord(symbol) for symbol in symbols]
codes

[36, 162, 163, 165, 8364, 164]
```

通过以上例子，我们可以发现一般来说使用列表推导式可以使得脚本更易于理解，但是列表推导式应尽量简洁，不要超过两行，如果有需要的话，可以使用 for 循环重写。

小技巧：

1. python 会忽略 []，{}，() 内部的换行，所以续行时无需使用转义符 “\”
2. 使用  []，{}，()  这三种括号时，python 会忽略末尾的逗号，所以平时最好在每一项后面都加上一个逗号，修改时比较方便，可读性也比较好

## 生成器表达式

生成器表达式和列表推导式几乎一样，只不过把方括号换成了圆括号。例如：

```python
tuple(ord(symbol) for symbol in symbols)
```

但是生成器表达式占用的内存更小，不会先构建整个列表，而是逐个产出项。比如两个各有 1000 项的列表，则使用生成器表达式计算笛卡尔积可以节省大量内存，因为不用先构建一个 100w 项的列表给 for 循环。

```python
colors = ['color1','color2','color3'...'color1000']
size = ['size1','size2','size3'...'size1000']
for shirt in (f'{c}, {s}' for c in colors for s in sizes'):
              print(shirt)
```

# 2.4 元组不仅仅是不可变列表

## 用作记录

```python
# 记录经纬度
lax_coordinates = (33,-118)

# 元组拆包赋值
city, year, pop, chg, area = ('Tokyo', '2003', '32450', '0.66', '8014')

# 元组拆包赋值
travel_ids = [('USA','31195'),('BRA','CE342567'),('ESP','XD2058')]
for passport in sorted(travel_ids):
    print('%s/%s' % passport)
    
# 元组拆包赋值以及虚拟变量占位
for country, _ in travel_ids:
    print(country)

>>>   
BRA/CE342567
ESP/XD2058
USA/31195
USA
BRA
ESP

```

小技巧：一般习惯用 “ _ ”来表示虚拟变量。在 match/case 语句中，_ 是通配符，匹配值但不绑定值。

## 用作不可变列表

元组作为不可变列表有两个好处：①只要在源码中见到元组，它的长度就用不可变②长度相同的元组和列表，元组占用的内存更小。

